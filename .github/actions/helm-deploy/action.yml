name: 'Helm Deploy'
description: 'Deploys applications to AKS using Helm charts'

inputs:
  environment:
    description: 'Target environment'
    required: true
  application_name:
    description: 'Application name'
    required: true
  application_type:
    description: 'Application type'
    required: true
  helm_chart_path:
    description: 'Path to Helm chart'
    required: true
  image_tag:
    description: 'Image tag'
    required: true
  helm_version:
    description: 'Helm chart version'
    required: true
  registry:
    description: 'Container registry'
    required: true
  aks_cluster_name:
    description: 'AKS cluster name'
    required: true
  aks_resource_group:
    description: 'AKS resource group'
    required: true
  keyvault_secrets_available:
    description: 'Whether Key Vault secrets are available'
    required: false
    default: 'false'
  use_managed_identity:
    description: 'Use managed identity for Azure authentication'
    required: false
    default: 'true'

outputs:
  deployment_status:
    description: 'Deployment status'
    value: ${{ steps.deploy.outputs.status }}
  release_name:
    description: 'Helm release name'
    value: ${{ steps.deploy.outputs.release_name }}

runs:
  using: 'composite'
  steps:
    - name: Install Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Get AKS credentials
      uses: azure/aks-set-context@v4
      with:
        resource-group: ${{ inputs.aks_resource_group }}
        cluster-name: ${{ inputs.aks_cluster_name }}
        use-kubelogin: true

    - name: Create namespace if not exists
      run: |
        NAMESPACE="${{ inputs.environment }}-${{ inputs.application_name }}"
        kubectl create namespace ${NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
        kubectl label namespace ${NAMESPACE} environment=${{ inputs.environment }} --overwrite
        kubectl label namespace ${NAMESPACE} application=${{ inputs.application_name }} --overwrite
        echo "namespace=${NAMESPACE}" >> $GITHUB_OUTPUT
      shell: bash
      id: namespace

    - name: Setup Key Vault secrets as Kubernetes secrets
      id: keyvault-secrets
      if: inputs.keyvault_secrets_available == 'true'
      run: |
        NAMESPACE="${{ steps.namespace.outputs.namespace }}"
        SECRET_NAME="${{ inputs.application_name }}-keyvault-secrets"
        
        echo "Setting up Key Vault secrets in Kubernetes..."
        
        # Check if secrets file exists
        if [[ -f "/tmp/keyvault-secrets/secrets.yaml" ]]; then
          echo "Found Key Vault secrets file"
          
          # Create Kubernetes secret from Key Vault secrets
          kubectl create secret generic ${SECRET_NAME} \
            --namespace=${NAMESPACE} \
            --from-env-file=/tmp/keyvault-secrets/secrets.env \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # Label the secret
          kubectl label secret ${SECRET_NAME} \
            --namespace=${NAMESPACE} \
            app.kubernetes.io/managed-by=helm \
            environment=${{ inputs.environment }} \
            source=azure-keyvault --overwrite
          
          echo "secret_created=true" >> $GITHUB_OUTPUT
          echo "secret_name=${SECRET_NAME}" >> $GITHUB_OUTPUT
        else
          echo "No Key Vault secrets found"
          echo "secret_created=false" >> $GITHUB_OUTPUT
        fi
      shell: bash

    - name: Prepare environment-specific Helm values
      id: values
      run: |
        NAMESPACE="${{ steps.namespace.outputs.namespace }}"
        ENVIRONMENT="${{ inputs.environment }}"
        
        # Determine values file to use
        BASE_VALUES_FILE="${{ inputs.helm_chart_path }}/values.yaml"
        ENV_VALUES_FILE="${{ inputs.helm_chart_path }}/values-${ENVIRONMENT}.yaml"
        
        # Check if environment-specific values file exists
        if [[ -f "${ENV_VALUES_FILE}" ]]; then
          echo "Using environment-specific values file: ${ENV_VALUES_FILE}"
          VALUES_FILES="-f ${BASE_VALUES_FILE} -f ${ENV_VALUES_FILE}"
        else
          echo "Environment-specific values file not found, using base values: ${BASE_VALUES_FILE}"
          VALUES_FILES="-f ${BASE_VALUES_FILE}"
        fi
        
        echo "values_files=${VALUES_FILES}" >> $GITHUB_OUTPUT
        
        # Create runtime values override file
        RUNTIME_VALUES="values-runtime-${ENVIRONMENT}.yaml"
        
        cat > ${RUNTIME_VALUES} << EOF
        # Runtime values for ${{ inputs.environment }}
        global:
          environment: ${ENVIRONMENT}
          applicationName: ${{ inputs.application_name }}
          applicationType: ${{ inputs.application_type }}
          
        image:
          repository: ${{ inputs.registry }}/${{ inputs.application_name }}
          tag: ${{ inputs.image_tag }}
          pullPolicy: $([ "${ENVIRONMENT}" = "production" ] && echo "IfNotPresent" || echo "Always")
          
        nameOverride: ${{ inputs.application_name }}
        fullnameOverride: ${{ inputs.application_name }}-${ENVIRONMENT}
        
        # Environment-specific overrides
        env:
          - name: ENVIRONMENT
            value: ${ENVIRONMENT}
          - name: APPLICATION_NAME
            value: ${{ inputs.application_name }}
          - name: BUILD_VERSION
            value: ${{ inputs.image_tag }}
          - name: NAMESPACE
            value: ${NAMESPACE}
        
        # Azure Workload Identity configuration
        serviceAccount:
          annotations:
            azure.workload.identity/client-id: ${{ vars.AZURE_CLIENT_ID }}
        
        podLabels:
          azure.workload.identity/use: "true"
        EOF
        
        # Add Key Vault secret reference if available
        if [[ "${{ steps.keyvault-secrets.outputs.secret_created }}" == "true" ]]; then
          cat >> ${RUNTIME_VALUES} << EOF
        
        # Key Vault secrets integration
        envFrom:
          - secretRef:
              name: ${{ steps.keyvault-secrets.outputs.secret_name }}
        
        # Additional secret volume mounts if needed
        extraSecretMounts:
          - name: keyvault-secrets
            secretName: ${{ steps.keyvault-secrets.outputs.secret_name }}
            mountPath: /etc/secrets
            readOnly: true
        EOF
        fi
        
        VALUES_FILES="${VALUES_FILES} -f ${RUNTIME_VALUES}"
        echo "values_files=${VALUES_FILES}" >> $GITHUB_OUTPUT
        echo "runtime_values=${RUNTIME_VALUES}" >> $GITHUB_OUTPUT
        
        echo "Generated runtime values file:"
        cat ${RUNTIME_VALUES}
      shell: bash

    - name: Lint Helm chart
      run: |
        echo "Linting Helm chart with values: ${{ steps.values.outputs.values_files }}"
        helm lint ${{ inputs.helm_chart_path }} ${{ steps.values.outputs.values_files }}
      shell: bash

    - name: Deploy with Helm
      id: deploy
      run: |
        NAMESPACE="${{ steps.namespace.outputs.namespace }}"
        RELEASE_NAME="${{ inputs.application_name }}-${{ inputs.environment }}"
        
        echo "Deploying ${RELEASE_NAME} to namespace ${NAMESPACE}"
        echo "Using values files: ${{ steps.values.outputs.values_files }}"
        
        # Check if release exists
        if helm list -n ${NAMESPACE} | grep -q ${RELEASE_NAME}; then
          echo "Upgrading existing release..."
          helm upgrade ${RELEASE_NAME} ${{ inputs.helm_chart_path }} \
            --namespace ${NAMESPACE} \
            ${{ steps.values.outputs.values_files }} \
            --set image.tag=${{ inputs.image_tag }} \
            --set image.repository=${{ inputs.registry }}/${{ inputs.application_name }} \
            --set global.environment=${{ inputs.environment }} \
            --set serviceAccount.annotations."azure\.workload\.identity/client-id"="${{ vars.AZURE_CLIENT_ID }}" \
            --version ${{ inputs.helm_version }} \
            --wait \
            --timeout 600s \
            --atomic \
            --history-max 10
        else
          echo "Installing new release..."
          helm install ${RELEASE_NAME} ${{ inputs.helm_chart_path }} \
            --namespace ${NAMESPACE} \
            ${{ steps.values.outputs.values_files }} \
            --set image.tag=${{ inputs.image_tag }} \
            --set image.repository=${{ inputs.registry }}/${{ inputs.application_name }} \
            --set global.environment=${{ inputs.environment }} \
            --set serviceAccount.annotations."azure\.workload\.identity/client-id"="${{ vars.AZURE_CLIENT_ID }}" \
            --version ${{ inputs.helm_version }} \
            --wait \
            --timeout 600s \
            --atomic
        fi
        
        echo "release_name=${RELEASE_NAME}" >> $GITHUB_OUTPUT
        echo "status=success" >> $GITHUB_OUTPUT
        
        # Get deployment status
        echo "=== Deployment Status ==="
        kubectl get pods -n ${NAMESPACE} -l app.kubernetes.io/name=${{ inputs.application_name }}
        kubectl get svc -n ${NAMESPACE} -l app.kubernetes.io/name=${{ inputs.application_name }}
        kubectl get ingress -n ${NAMESPACE} -l app.kubernetes.io/name=${{ inputs.application_name }} || echo "No ingress found"
        
        echo "Deployment completed successfully!"
      shell: bash

    - name: Run post-deployment health checks
      run: |
        NAMESPACE="${{ steps.namespace.outputs.namespace }}"
        RELEASE_NAME="${{ steps.deploy.outputs.release_name }}"
        
        echo "Running post-deployment health checks..."
        
        # Wait for deployment to be ready
        kubectl wait --for=condition=available deployment/${RELEASE_NAME} -n ${NAMESPACE} --timeout=300s
        
        # Check pod status
        echo "=== Pod Status ==="
        kubectl get pods -n ${NAMESPACE} -l app.kubernetes.io/name=${{ inputs.application_name }} -o wide
        
        # Check service endpoints
        echo "=== Service Endpoints ==="
        kubectl get endpoints -n ${NAMESPACE} -l app.kubernetes.io/name=${{ inputs.application_name }}
        
        # Verify Azure Workload Identity configuration
        echo "=== Azure Workload Identity Status ==="
        kubectl get pods -n ${NAMESPACE} -l app.kubernetes.io/name=${{ inputs.application_name }} -o jsonpath='{.items[0].metadata.labels.azure\.workload\.identity/use}' || echo "Workload Identity not configured"
        
        # Run Helm test if tests exist
        if helm test ${RELEASE_NAME} --namespace ${NAMESPACE} --timeout 300s; then
          echo "✅ Helm tests passed"
        else
          echo "⚠️  Helm tests failed or not available"
        fi
        
        echo "✅ Health checks completed"
      shell: bash

    - name: Verify Key Vault integration
      if: inputs.keyvault_secrets_available == 'true'
      run: |
        NAMESPACE="${{ steps.namespace.outputs.namespace }}"
        
        echo "Verifying Key Vault secret integration..."
        
        # Check if secret exists
        if kubectl get secret ${{ steps.keyvault-secrets.outputs.secret_name }} -n ${NAMESPACE} >/dev/null 2>&1; then
          echo "✅ Key Vault secret successfully created in Kubernetes"
          
          # List secret keys (without values for security)
          echo "Secret contains the following keys:"
          kubectl get secret ${{ steps.keyvault-secrets.outputs.secret_name }} -n ${NAMESPACE} -o jsonpath='{.data}' | jq -r 'keys[]' || echo "Unable to list keys"
        else
          echo "❌ Key Vault secret not found in Kubernetes"
          exit 1
        fi
      shell: bash

    - name: Verify Azure Workload Identity integration
      if: inputs.use_managed_identity == 'true'
      run: |
        NAMESPACE="${{ steps.namespace.outputs.namespace }}"
        
        echo "Verifying Azure Workload Identity integration..."
        
        # Check service account annotations
        if kubectl get serviceaccount ${{ inputs.application_name }}-${{ inputs.environment }} -n ${NAMESPACE} -o jsonpath='{.metadata.annotations.azure\.workload\.identity/client-id}' | grep -q "${{ vars.AZURE_CLIENT_ID }}"; then
          echo "✅ Service account correctly configured with Workload Identity"
        else
          echo "⚠️  Service account may not be correctly configured for Workload Identity"
        fi
        
        # Check pod labels
        POD_NAME=$(kubectl get pods -n ${NAMESPACE} -l app.kubernetes.io/name=${{ inputs.application_name }} -o jsonpath='{.items[0].metadata.name}')
        if [[ -n "${POD_NAME}" ]]; then
          if kubectl get pod ${POD_NAME} -n ${NAMESPACE} -o jsonpath='{.metadata.labels.azure\.workload\.identity/use}' | grep -q "true"; then
            echo "✅ Pod correctly labeled for Workload Identity"
          else
            echo "⚠️  Pod may not be correctly labeled for Workload Identity"
          fi
        fi
      shell: bash

    - name: Generate deployment summary
      run: |
        NAMESPACE="${{ steps.namespace.outputs.namespace }}"
        RELEASE_NAME="${{ steps.deploy.outputs.release_name }}"
        
        cat >> $GITHUB_STEP_SUMMARY << EOF
        ## 🚀 Deployment Summary
        
        **Application:** ${{ inputs.application_name }}
        **Environment:** ${{ inputs.environment }}
        **Image Tag:** ${{ inputs.image_tag }}
        **Helm Chart Version:** ${{ inputs.helm_version }}
        **Namespace:** ${NAMESPACE}
        **Release Name:** ${RELEASE_NAME}
        **Key Vault Integration:** ${{ inputs.keyvault_secrets_available }}
        **Managed Identity:** ${{ inputs.use_managed_identity }}
        
        ### 📊 Deployment Status
        \`\`\`
        $(kubectl get pods -n ${NAMESPACE} -l app.kubernetes.io/name=${{ inputs.application_name }})
        \`\`\`
        
        ### 🌐 Service Information
        \`\`\`
        $(kubectl get svc -n ${NAMESPACE} -l app.kubernetes.io/name=${{ inputs.application_name }})
        \`\`\`
        
        ### 🔗 Ingress Information
        \`\`\`
        $(kubectl get ingress -n ${NAMESPACE} -l app.kubernetes.io/name=${{ inputs.application_name }} 2>/dev/null || echo "No ingress configured")
        \`\`\`
        
        ### 🔐 Security Configuration
        $(if [[ "${{ inputs.keyvault_secrets_available }}" == "true" ]]; then
          echo "✅ Azure Key Vault secrets integrated"
          echo "\`\`\`"
          echo "Secret Name: ${{ steps.keyvault-secrets.outputs.secret_name }}"
          echo "Namespace: ${NAMESPACE}"
          echo "\`\`\`"
        else
          echo "ℹ️ No Key Vault secrets configured"
        fi)
        
        $(if [[ "${{ inputs.use_managed_identity }}" == "true" ]]; then
          echo "✅ Azure Workload Identity enabled"
          echo "\`\`\`"
          echo "Client ID: ${{ vars.AZURE_CLIENT_ID }}"
          echo "Service Account: ${{ inputs.application_name }}-${{ inputs.environment }}"
          echo "\`\`\`"
        else
          echo "ℹ️ Managed Identity not configured"
        fi)
        
        ### 📈 Helm Release Status
        \`\`\`
        $(helm status ${RELEASE_NAME} -n ${NAMESPACE} --show-desc)
        \`\`\`
        EOF
      shell: bash

    - name: Cleanup temporary files
      run: |
        # Clean up temporary values files
        rm -f values-runtime-*.yaml
        echo "Temporary files cleaned up"
      shell: bash