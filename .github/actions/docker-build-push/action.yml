name: 'Docker Build and Push'
description: 'Builds and pushes Docker images with caching and multi-arch support'

inputs:
  application_name:
    description: 'Application name'
    required: true
  application_type:
    description: 'Application type (java-springboot, nodejs)'
    required: true
  build_context:
    description: 'Build context path'
    required: true
  dockerfile_path:
    description: 'Path to Dockerfile'
    required: true
  image_tag:
    description: 'Image tag'
    required: true
  registry:
    description: 'Container registry'
    required: true
  use_managed_identity:
    description: 'Use managed identity for registry authentication'
    required: false
    default: 'true'
  registry_username:
    description: 'Registry username (deprecated, use managed identity instead)'
    required: false
    default: ''
  registry_password:
    description: 'Registry password (deprecated, use managed identity instead)'
    required: false
    default: ''

outputs:
  image_digest:
    description: 'Image digest'
    value: ${{ steps.build.outputs.digest }}
  image_url:
    description: 'Full image URL'
    value: ${{ steps.build.outputs.image_url }}

runs:
  using: 'composite'
  steps:
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        platforms: linux/amd64,linux/arm64

    - name: Login to Azure Container Registry with Managed Identity
      if: inputs.use_managed_identity == 'true'
      run: |
        echo "Logging into Azure Container Registry using managed identity..."
        
        # Get access token using managed identity
        ACCESS_TOKEN=$(az acr login --name ${{ inputs.registry }} --expose-token --output tsv --query accessToken)
        
        if [ -z "$ACCESS_TOKEN" ]; then
          echo "Failed to get ACR access token"
          exit 1
        fi
        
        # Login to Docker using the access token
        echo "$ACCESS_TOKEN" | docker login ${{ inputs.registry }} --username 00000000-0000-0000-0000-000000000000 --password-stdin
        
        echo "Successfully logged into ACR with managed identity"
      shell: bash

    - name: Login to Container Registry with Username/Password
      if: inputs.use_managed_identity != 'true' && inputs.registry_username != '' && inputs.registry_password != ''
      uses: docker/login-action@v3
      with:
        registry: ${{ inputs.registry }}
        username: ${{ inputs.registry_username }}
        password: ${{ inputs.registry_password }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ inputs.registry }}/${{ inputs.application_name }}
        tags: |
          type=raw,value=${{ inputs.image_tag }}
          type=raw,value=latest,enable={{is_default_branch}}
        labels: |
          org.opencontainers.image.title=${{ inputs.application_name }}
          org.opencontainers.image.description=Container image for ${{ inputs.application_name }}
          org.opencontainers.image.vendor=Your Organization
          org.opencontainers.image.version=${{ inputs.image_tag }}
          org.opencontainers.image.revision=${{ github.sha }}
          org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
          org.opencontainers.image.created=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
          azure.workload.identity/use=true

    - name: Set up build cache
      id: cache
      run: |
        CACHE_FROM=""
        CACHE_TO=""
        
        # Configure cache based on application type
        case "${{ inputs.application_type }}" in
          "java-springboot")
            CACHE_FROM="type=gha,scope=java-${{ inputs.application_name }}"
            CACHE_TO="type=gha,mode=max,scope=java-${{ inputs.application_name }}"
            ;;
          "nodejs")
            CACHE_FROM="type=gha,scope=nodejs-${{ inputs.application_name }}"
            CACHE_TO="type=gha,mode=max,scope=nodejs-${{ inputs.application_name }}"
            ;;
          *)
            CACHE_FROM="type=gha,scope=default-${{ inputs.application_name }}"
            CACHE_TO="type=gha,mode=max,scope=default-${{ inputs.application_name }}"
            ;;
        esac
        
        echo "cache_from=${CACHE_FROM}" >> $GITHUB_OUTPUT
        echo "cache_to=${CACHE_TO}" >> $GITHUB_OUTPUT
      shell: bash

    - name: Prepare build context for Java applications
      if: inputs.application_type == 'java-springboot'
      run: |
        echo "Preparing Java application build context..."
        cd "${{ inputs.build_context }}"
        
        # List available JAR files
        echo "Available JAR files in build context:"
        find . -name "*.jar" -type f 2>/dev/null || echo "No JAR files found yet"
        
        # Ensure we have a JAR file for Docker build
        JAR_COUNT=$(find . -name "*.jar" -not -name "*-sources.jar" -not -name "*-javadoc.jar" -type f 2>/dev/null | wc -l)
        if [ "$JAR_COUNT" -eq 0 ]; then
          echo "Warning: No JAR files found in build context. Make sure Maven build artifacts were downloaded correctly."
          ls -la
        else
          echo "Found $JAR_COUNT JAR file(s) for Docker build"
          find . -name "*.jar" -not -name "*-sources.jar" -not -name "*-javadoc.jar" -type f -exec ls -la {} \;
        fi
      shell: bash

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: ${{ inputs.build_context }}
        file: ${{ inputs.dockerfile_path }}
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: ${{ steps.cache.outputs.cache_from }}
        cache-to: ${{ steps.cache.outputs.cache_to }}
        build-args: |
          APPLICATION_NAME=${{ inputs.application_name }}
          APPLICATION_TYPE=${{ inputs.application_type }}
          BUILD_VERSION=${{ inputs.image_tag }}
          BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
          BUILD_REVISION=${{ github.sha }}

    - name: Set outputs
      id: outputs
      run: |
        IMAGE_URL="${{ inputs.registry }}/${{ inputs.application_name }}:${{ inputs.image_tag }}"
        echo "image_url=${IMAGE_URL}" >> $GITHUB_OUTPUT
        echo "Built and pushed image: ${IMAGE_URL}"
        
        # Verify image exists in registry
        if ${{ inputs.use_managed_identity == 'true' }}; then
          echo "Verifying image in ACR using managed identity..."
          az acr repository show --name $(echo "${{ inputs.registry }}" | cut -d'.' -f1) --image "${{ inputs.application_name }}:${{ inputs.image_tag }}" --output table || echo "Image verification failed"
        fi
      shell: bash

    - name: Generate SBOM
      uses: anchore/sbom-action@v0
      with:
        image: ${{ steps.outputs.outputs.image_url }}
        format: spdx-json
        output-file: "${{ inputs.application_name }}-sbom.spdx.json"

    - name: Upload SBOM
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.application_name }}-sbom
        path: "${{ inputs.application_name }}-sbom.spdx.json"
        retention-days: 30

    - name: Security scan with Trivy
      if: inputs.use_managed_identity == 'true'
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ steps.outputs.outputs.image_url }}
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results
      if: inputs.use_managed_identity == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.application_name }}-security-scan
        path: 'trivy-results.sarif'
        retention-days: 30