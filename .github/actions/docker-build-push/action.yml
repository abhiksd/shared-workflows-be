name: 'Docker Build and Push'
description: 'Builds and pushes Docker images with caching and multi-arch support'

inputs:
  application_name:
    description: 'Application name'
    required: true
  application_type:
    description: 'Application type (java-springboot, nodejs)'
    required: true
  build_context:
    description: 'Build context path'
    required: true
  dockerfile_path:
    description: 'Path to Dockerfile'
    required: true
  image_tag:
    description: 'Image tag'
    required: true
  registry:
    description: 'Container registry'
    required: true
  azure_tenant_id:
    description: 'Azure Tenant ID for Managed Identity authentication'
    required: true
  azure_client_id:
    description: 'Azure Client ID for Managed Identity authentication'
    required: true

outputs:
  image_digest:
    description: 'Image digest'
    value: ${{ steps.build.outputs.digest }}
  image_url:
    description: 'Full image URL'
    value: ${{ steps.build.outputs.image_url }}

runs:
  using: 'composite'
  steps:
    - name: Azure Login with Managed Identity
      uses: azure/login@v1
      with:
        auth-type: IDENTITY
        tenant-id: ${{ inputs.azure_tenant_id }}
        client-id: ${{ inputs.azure_client_id }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        platforms: linux/amd64,linux/arm64

    - name: Login to Azure Container Registry with Managed Identity
      run: |
        # Get ACR login server name from the registry URL
        ACR_NAME=$(echo "${{ inputs.registry }}" | cut -d'.' -f1)
        
        # Login to ACR using managed identity
        az acr login --name ${ACR_NAME}
        
        echo "Successfully authenticated to ACR: ${{ inputs.registry }}"
      shell: bash

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ inputs.registry }}/${{ inputs.application_name }}
        tags: |
          type=raw,value=${{ inputs.image_tag }}
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Set up build cache
      id: cache
      run: |
        CACHE_FROM=""
        CACHE_TO=""
        
        # Configure cache based on application type
        case "${{ inputs.application_type }}" in
          "java-springboot")
            CACHE_FROM="type=gha,scope=java-${{ inputs.application_name }}"
            CACHE_TO="type=gha,mode=max,scope=java-${{ inputs.application_name }}"
            ;;
          "nodejs")
            CACHE_FROM="type=gha,scope=nodejs-${{ inputs.application_name }}"
            CACHE_TO="type=gha,mode=max,scope=nodejs-${{ inputs.application_name }}"
            ;;
          *)
            CACHE_FROM="type=gha,scope=default-${{ inputs.application_name }}"
            CACHE_TO="type=gha,mode=max,scope=default-${{ inputs.application_name }}"
            ;;
        esac
        
        echo "cache_from=${CACHE_FROM}" >> $GITHUB_OUTPUT
        echo "cache_to=${CACHE_TO}" >> $GITHUB_OUTPUT
      shell: bash

    - name: Prepare build context for Java applications
      if: inputs.application_type == 'java-springboot'
      run: |
        echo "Preparing Java application build context..."
        cd "${{ inputs.build_context }}"
        
        # List available JAR files
        echo "Available JAR files in build context:"
        find . -name "*.jar" -type f 2>/dev/null || echo "No JAR files found yet"
        
        # Ensure we have a JAR file for Docker build
        JAR_COUNT=$(find . -name "*.jar" -not -name "*-sources.jar" -not -name "*-javadoc.jar" -type f 2>/dev/null | wc -l)
        if [ "$JAR_COUNT" -eq 0 ]; then
          echo "Warning: No JAR files found in build context. Make sure Maven build artifacts were downloaded correctly."
          ls -la
        else
          echo "Found $JAR_COUNT JAR file(s) for Docker build"
          find . -name "*.jar" -not -name "*-sources.jar" -not -name "*-javadoc.jar" -type f -exec ls -la {} \;
        fi
      shell: bash

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: ${{ inputs.build_context }}
        file: ${{ inputs.dockerfile_path }}
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: ${{ steps.cache.outputs.cache_from }}
        cache-to: ${{ steps.cache.outputs.cache_to }}
        build-args: |
          APPLICATION_NAME=${{ inputs.application_name }}
          APPLICATION_TYPE=${{ inputs.application_type }}
          BUILD_VERSION=${{ inputs.image_tag }}
          BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
          BUILD_REVISION=${{ github.sha }}

    - name: Set outputs
      id: outputs
      run: |
        IMAGE_URL="${{ inputs.registry }}/${{ inputs.application_name }}:${{ inputs.image_tag }}"
        echo "image_url=${IMAGE_URL}" >> $GITHUB_OUTPUT
        echo "Built and pushed image: ${IMAGE_URL}"
      shell: bash

    - name: Generate SBOM
      uses: anchore/sbom-action@v0
      with:
        image: ${{ steps.outputs.outputs.image_url }}
        format: spdx-json
        output-file: "${{ inputs.application_name }}-sbom.spdx.json"

    - name: Upload SBOM
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.application_name }}-sbom
        path: "${{ inputs.application_name }}-sbom.spdx.json"
        retention-days: 30